import modelsPromise from '../models/index.js';
import queue from '../services/queue/index.js';
import debug from 'debug';
import { ExpressRequest, ExpressResponse, ExpressNext } from '../types/express.js';
import { Op } from 'sequelize';
import _ from 'lodash';
import { extractSequelizeModelMetadata } from '../mcp/utils/schema-metadata.js';

const debugLog = debug('<%= object %>sController');
const service = '<%= service %>s';

async function getModels(): Promise<{ Model: any; Trash: any; models: any }> {
  const m = await modelsPromise;
  return { Model: m.<%= service %>s, Trash: m.Trash, models: m };
}

type <%= service %>sRouteHandler = (req: ExpressRequest, res: ExpressResponse, next: ExpressNext) => Promise<void>;

export interface <%= service %>sControllerType {
  buildProjection(projections: string): string[];
  find: <%= service %>sRouteHandler;
  getSchema: <%= service %>sRouteHandler;
  findOne: <%= service %>sRouteHandler;
  create: <%= service %>sRouteHandler;
  update: <%= service %>sRouteHandler;
  updateOne: <%= service %>sRouteHandler;
  delete: <%= service %>sRouteHandler;
  deleteOne: <%= service %>sRouteHandler;
  restore: <%= service %>sRouteHandler;
}

const <%= service %>sController: <%= service %>sControllerType = {
  buildProjection(projections: string): string[] {
    debugLog('starting build...');
    const projection = projections.split(','); // Projection should be comma separated. eg. name,location
    return projection.filter((field) => typeof field === 'string' && field.trim()).map(f => f.trim());
  },

  /**
   * Find multiple <%= service %> records with filtering, pagination, and search
   * @mcp.expose true
   * @mcp.toolName find<%= service %>s
   * @mcp.description Find and list <%= service %> records with optional filtering, pagination, sorting, and full-text search
   */
  find: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model } = await getModels();
      let query: any = {};
      
      if (req.query.search) {
        const raw = req.query.search;
        let parsed: any;
        try {
          parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;
        } catch {
          parsed = raw;
        }
        if (typeof parsed === 'string') {
          const resp = await (Model as any).search(parsed);
          res.ok?.(JSON.parse(JSON.stringify(resp)));
          return;
        }
        query = parsed;
        // Clean appId and userId
        if (query && query.appId) {
          delete query.appId;
        }
        if (query && query.accountId) {
          delete query.accountId;
        }
      } else {
        query = { ...req.query };
        // Clean appId and userId
        if (query && query.appId) {
          delete query.appId;
        }
        if (query && query.accountId) {
          delete query.accountId;
        }
      }

      const _query: any = {};
        const projection = query.select; // Projection should be comma separated. eg. name,location
        let ourProjection: string[] | undefined;
        
        if (projection) {
          ourProjection = <%= service %>sController.buildProjection(projection);
          delete query.select;
        }
        
        let limit = query.limit ? parseInt(query.limit as string, 10) : undefined;
        if (limit) {
          delete query.limit;
        }

        const from = query.from;
        const to = query.to;
        if (from) {
          query.createdAt = {};
          query.createdAt[Op.gte] = from;
          delete query.from;
          if (to) {
            delete query.to;
          } else {
            query.createdAt[Op.lte] = new Date().toISOString();
          }
          query.createdAt[Op.lte] = to || new Date().toISOString();
        } else {
          query.createdAt = {};
          query.createdAt[Op.gte] = new Date('1989-03-15T00:00:00').toISOString();
          if (to) {
            delete query.to;
          }
          query.createdAt[Op.lte] = to || new Date().toISOString();
        }
        
        const lastId = query.lastId ? parseInt(query.lastId as string, 10) : undefined;
        if (lastId) {
          if (query.desc) {
            query._id = {};
            query._id[Op.lt] = lastId;
            delete query.desc;
          } else {
            query._id = {};
            query._id[Op.gt] = lastId;
          }
          delete query.lastId;
        }
        if (query.desc) {
          delete query.desc;
        }
        
        const sort = query.sort; // -fieldName: means descending while fieldName without the minus mean ascending both by fieldName. eg, '-fieldName1 fieldName2'
        if (sort) {
          delete query.sort;
        }
        
        const populate = query.populate; // Samples: 'name location' will populate name and location references. only supports this for now | 'name', 'firstname' will populate name reference and only pick the firstname attribute
        if (populate) {
          delete query.populate;
        }

        if (limit) {
          _query.limit = limit;
        } else {
          limit = 50;
          _query.limit = limit;
        }
        
        _query.where = query;
        const totalResult = (Model as any).count({ where: query });
        const total = (Model as any).count({});

        if (sort) {
          _query.order = [];
          const splitSort = sort.split(' ');
          for (const sortField of splitSort) {
            if (typeof sortField === 'string' && sortField.trim()) {
              if (sortField[0] === '-') {
                _query.order.push([sortField.substr(1), 'DESC']);
              } else {
                _query.order.push([sortField, 'ASC']);
              }
            }
          }
        }

        if (populate) {
          _query.include = [];
          const splitPopulation = populate.split(' ');
          for (const popField of splitPopulation) {
            if (typeof popField === 'string' && popField.trim() && (models as any)[popField.trim()]) {
              _query.include.push({ model: (models as any)[popField.trim()] });
            }
          }
        }

        if (projection && ourProjection) {
          ourProjection.push('_id');
          _query.attributes = ourProjection;
          const [resp, totalCount, totalResultCount] = await Promise.all([
            (Model as any).findAll(_query),
            total,
            totalResult
          ]);
          
          const ourLastId = resp.length === 0 ? null : resp[resp.length - 1]._id;
          const extraData = {
            limit: limit * 1,
            total: totalCount,
            totalResult: totalResultCount,
            lastId: ourLastId,
            isLastPage: (totalResultCount < limit)
          };
          res.ok?.(JSON.parse(JSON.stringify(resp)), false, extraData);
        } else {
          const [resp, totalCount, totalResultCount] = await Promise.all([
            (Model as any).findAll(_query),
            total,
            totalResult
          ]);
          
          const ourLastId = resp.length === 0 ? null : resp[resp.length - 1]._id;
          const extraData = {
            limit: limit * 1,
            total: totalCount,
            lastId: ourLastId,
            totalResult: totalResultCount,
            isLastPage: (totalResultCount < limit)
          };
          res.ok?.(JSON.parse(JSON.stringify(resp)), false, extraData);
        }
      }
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Find a single <%= service %> record by ID
   * @mcp.expose true
   * @mcp.toolName get<%= service %>ById
   * @mcp.description Retrieve a single <%= service %> record by its unique identifier
   */
  findOne: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, models } = await getModels();
      const _query: any = {};
      const id = req.params.id;
      const query: any = req.query || {};
      const populate = query.populate; // Samples: 'name location' will populate name and location references. only supports this for now | 'name', 'firstname' will populate name reference and only pick the firstname attribute
      
      _query.where = { _id: id };

      if (populate) {
        delete query.populate;
        _query.include = [];
        const splitPopulation = populate.split(' ');
        for (const popField of splitPopulation) {
          if (typeof popField === 'string' && popField.trim() && (models as any)[popField.trim()]) {
            _query.include.push({ model: (models as any)[popField.trim()] });
          }
        }
      }

      const resp = await (Model as any).findOne(_query);
      if (!resp) {
        res.notFound?.();
      } else {
        res.ok?.(resp.toJSON());
      }
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Create a new <%= service %> record
   * @mcp.expose true
   * @mcp.toolName create<%= service %>
   * @mcp.description Create a new <%= service %> record with the provided data
   */
  create: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model } = await getModels();
      const data: any = Array.isArray(req.body) ? [...req.body] : { ...req.body };
      if (data && (data as any).secure) {
        delete (data as any).secure;
      }

      let resp;
      if (Array.isArray(data)) {
        resp = await (Model as any).bulkCreate(data);
      } else {
        resp = await (Model as any).create(data);
      }
      
      res.ok?.(resp);
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Update multiple <%= service %> records matching the query
   * @mcp.expose true
   * @mcp.toolName update<%= service %>s
   * @mcp.description Update multiple <%= service %> records that match the specified query criteria
   */
  update: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model } = await getModels();
      const query: any = { ...req.query };
      const _query: any = {};
      // Clean appId and userId
      if (query && query.appId) {
        delete query.appId;
      }
      if (query && query.accountId) {
        delete query.accountId;
      }
      
      const data: any = { ...req.body };
      if (data && data.secure) {
        delete data.secure;
      }

      _query.where = query;
      const resp = await (Model as any).update(data, _query);
      res.ok?.(resp);
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Update a single <%= service %> record by ID
   * @mcp.expose true
   * @mcp.toolName update<%= service %>ById
   * @mcp.description Update a single <%= service %> record by its unique identifier
   */
  updateOne: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model } = await getModels();
      const _query: any = {};
      const id = req.params.id;
      const data: any = { ...req.body };
      if (data && data.secure) {
        delete data.secure;
      }
      
      _query.where = { _id: id };
      const resp = await (Model as any).update(data, _query);
      if (!resp || resp[0] === 0) {
        res.notFound?.();
      } else {
        const updated = await (Model as any).findOne({ where: { _id: id } });
        res.ok?.(updated);
      }
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Delete multiple <%= service %> records matching the query
   * @mcp.expose true
   * @mcp.toolName delete<%= service %>s
   * @mcp.description Delete multiple <%= service %> records that match the specified query criteria. Deleted records are moved to trash for potential restoration.
   */
  delete: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model } = await getModels();
      const _query: any = {};
      const query: any = { ...req.query };
      // Clean appId and userId
      if (query && query.appId) {
        delete query.appId;
      }
      if (query && query.accountId) {
        delete query.accountId;
      }
      // Convert MongoDB-style _id operators to Sequelize Op
      if (query._id && typeof query._id === 'object' && !(query._id instanceof Date)) {
        const idCond: any = {};
        if (query._id.$gt != null) { idCond[Op.gt] = query._id.$gt; }
        if (query._id.$lt != null) { idCond[Op.lt] = query._id.$lt; }
        if (query._id.$gte != null) { idCond[Op.gte] = query._id.$gte; }
        if (query._id.$lte != null) { idCond[Op.lte] = query._id.$lte; }
        if (Object.keys(idCond).length) {
          query._id = idCond;
        }
      }

      _query.where = query;

      // Find matches
      const resp = await (Model as any).findAll(_query);
      
      // Backup data in Trash and delete
      for (const item of resp) {
        const backupData = {
          service: service,
          data: item.toJSON(),
          owner: req.accountId,
          deletedBy: req.accountId,
          client: req.appId,
          developer: req.developer
        };
        
        queue.create('saveToTrash', backupData).save();
        await item.destroy();
      }
      
      res.ok?.(resp.map((r: any) => r.toJSON()));
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Delete a single <%= service %> record by ID
   * @mcp.expose true
   * @mcp.toolName delete<%= service %>ById
   * @mcp.description Delete a single <%= service %> record by its unique identifier. The deleted record is moved to trash for potential restoration.
   */
  deleteOne: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model } = await getModels();
      const _query: any = {};
      const id = req.params.id;

      _query.where = { _id: id };
      
      // Find match
      const resp = await (Model as any).findOne(_query);
      if (!resp) {
        res.notFound?.();
        return;
      }
      
      // Backup data in Trash
      const backupData = {
        service: service,
        data: resp.toJSON(),
        owner: req.accountId,
        deletedBy: req.accountId,
        client: req.appId,
        developer: req.developer
      };

      queue.create('saveToTrash', backupData).save();

      await resp.destroy();
      res.ok?.(backupData.data);
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Restore a deleted <%= service %> record from trash
   * @mcp.expose true
   * @mcp.toolName restore<%= service %>
   * @mcp.description Restore a previously deleted <%= service %> record from the trash back to the main collection
   */
  restore: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      const id = req.params.id;
      
      // Find data by ID from trash
      const trashItem = await (Trash as any).findById(id).lean();
      if (!trashItem) {
        res.notFound?.();
        return;
      }
      
      // Restore to DB
      const resp = await (Model as any).create(trashItem.data);
      
      // Delete from trash
      await (Trash as any).findByIdAndDelete(id);
      res.ok?.(resp);
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Get schema metadata for this model (SQL)
   * @mcp.expose true
   * @mcp.toolName get<%= service %>Schema
   * @mcp.description Get the schema definition for <%= service %> records (fields, types, descriptions) for use by MCP and API consumers
   */
  getSchema: async function (_req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model } = await getModels();
      const modelName = service;
      const metadata = extractSequelizeModelMetadata(modelName, Model as import('../types/models.js').SequelizeModelType);
      if (!metadata) {
        res.notFound?.();
        return;
      }
      res.ok?.(metadata);
    } catch (err: any) {
      next(err);
    }
  }
};

export default <%= service %>sController;
