/* eslint-disable @typescript-eslint/no-explicit-any -- generated model uses any for schema/types */
import db from '../services/database/index.js';
import mongoose, { Schema, Document, Model as MongooseModel } from 'mongoose';
import { SchemaFieldDefinition } from '../types/models.js';
import queue from '../services/queue/index.js';
import debug from 'debug';

const collection = '<%= service %>s';
const debugLog = debug(collection);

const schemaObject: Record<string, SchemaFieldDefinition | any> = {
    // ++++++++++++++ Modify to your own schema ++++++++++++++++++
    name: {
        type: String,
        description: 'Name field description',
        mcpDescription: 'Detailed description for LLM context about what this name field represents and how it\'s used'
    },
    someOtherStringData: {
        type: String,
        description: 'Some other string data description',
        mcpDescription: 'Detailed description for LLM context about this field'
    },
    toPop: {
        type: Schema.Types.ObjectId,
        ref: '<%= service %>s',
        description: 'Reference to another <%= service %>',
        mcpDescription: 'Reference to another <%= service %> record. Used for populating related data.'
    }
    // ++++++++++++++ Modify to your own schema ++++++++++++++++++
};

schemaObject.createdAt = {
    type: Date,
    default: Date.now,
    description: 'Creation timestamp',
    mcpDescription: 'Date and time when the record was created. Automatically set on creation.'
};

schemaObject.updatedAt = {
    type: Date,
    description: 'Update timestamp',
    mcpDescription: 'Date and time when the record was last updated. Automatically updated on save.'
};

schemaObject.owner = {
    type: Schema.Types.ObjectId,
    ref: 'Accounts',
    description: 'Owner account ID',
    mcpDescription: 'Reference to the account that owns this record'
};

schemaObject.createdBy = {
    type: Schema.Types.ObjectId,
    ref: 'Accounts',
    description: 'Creator account ID',
    mcpDescription: 'Reference to the account that created this record'
};

schemaObject.client = {
    type: Schema.Types.ObjectId,
    ref: 'Clients',
    description: 'Client ID',
    mcpDescription: 'Reference to the client application associated with this record'
};

schemaObject.developer = {
    type: Schema.Types.ObjectId,
    ref: 'Users',
    description: 'Developer user ID',
    mcpDescription: 'Reference to the developer user associated with this record'
};

schemaObject.tags = {
    type: [String],
    index: 'text',
    description: 'Search tags',
    mcpDescription: 'Array of searchable tags extracted from record data for full-text search. Used for searching and filtering records.'
};

// Let us define our schema
const SchemaDefinition = new mongoose.Schema(schemaObject);

// Index all text for full text search
// MyModel.find({$text: {$search: searchString}})
//    .skip(20)
//    .limit(10)
//    .exec(function(err, docs) { ... });
// SchemaDefinition.index({'tags': 'text'});

SchemaDefinition.statics.search = function(string: string) {
    return this.find({$text: {$search: string}}, { score : { $meta: "textScore" } })
    .sort({ score : { $meta : 'textScore' } });
};

// assign a function to the "methods" object of our Schema
// SchemaDefinition.methods.someMethod = function (cb) {
//     return this.model(collection).find({}, cb);
// };

// assign a function to the "statics" object of our Schema
// SchemaDefinition.statics.someStaticFunction = function(query, cb) {
// eg. pagination
    // this.find(query, null, { skip: 10, limit: 5 }, cb);
// };

// Adding hooks

SchemaDefinition.pre('save', function(this: mongoose.Document, next: () => void) {
    // Indexing for search
    const ourDoc = (this as any)._doc;

    ourDoc.model = collection;

    // Dump it in the queue
    queue.create('searchIndex', ourDoc)
    .save();

    next();
});

SchemaDefinition.post('init', function(doc: Document) {
  debugLog('%s has been initialized from the db', doc._id);
});

SchemaDefinition.post('validate', function(doc: Document) {
  debugLog('%s has been validated (but not saved yet)', doc._id);
});

SchemaDefinition.post('save', function(doc: Document) {
  debugLog('%s has been saved', doc._id);
});

// Note: 'remove' hook is deprecated in Mongoose, using 'findOneAndDelete' instead
// SchemaDefinition.post('findOneAndDelete', function(doc: Document) {
//   debugLog('%s has been removed', doc._id);
// });

SchemaDefinition.pre('validate', function(next: () => void) {
  debugLog('this gets printed first');
  next();
});

SchemaDefinition.post('validate', function() {
  debugLog('this gets printed second');
});

SchemaDefinition.pre('find', function(this: mongoose.Query<any, any>, next: () => void) {
  debugLog(this instanceof mongoose.Query); // true
  (this as any).start = Date.now();
  next();
});

SchemaDefinition.post('find', function(this: mongoose.Query<any, any> & { start?: number }, result: any) {
  debugLog(this instanceof mongoose.Query); // true
  // prints returned documents
  debugLog('find() returned ' + JSON.stringify(result));
  // prints number of milliseconds the query took
  debugLog('find() took ' + ((Date.now() - (this.start || 0)) + ' millis'));
});

SchemaDefinition.pre(['updateOne', 'updateMany'], function(this: mongoose.Query<any, any>, next: () => void) {
    // Indexing for search
    const ourDoc = (this as any)._update;
    ourDoc.model = collection;
    ourDoc.update = true;
    if(ourDoc.updatedAt || ourDoc.tags){ /* jslint ignore:line */
        // Move along! Nothing to see here!!
    }else{
        // Dump it in the queue
        queue.create('searchIndex', ourDoc)
        .save();
    }

    ourDoc.updatedAt = new Date(Date.now()).toISOString();
    
    next();
});

interface <%= service %>Document extends Document {
    name?: string;
    someOtherStringData?: string;
    toPop?: Schema.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
    owner?: Schema.Types.ObjectId;
    createdBy?: Schema.Types.ObjectId;
    client?: Schema.Types.ObjectId;
    developer?: Schema.Types.ObjectId;
    tags?: string[];
}

interface <%= service %>Model extends MongooseModel<<%= service %>Document> {
    search(string: string): any;
}

const Model = db.mongo.model<<%= service %>Document, <%= service %>Model>(collection, SchemaDefinition) as <%= service %>Model;
(Model as any)._mongoose = mongoose;

export default Model;
