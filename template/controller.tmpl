import modelsPromise from '../models/index.js';
import queue from '../services/queue/index.js';
import debug from 'debug';
import { ExpressRequest, ExpressResponse, ExpressNext } from '../types/express.js';
import { discoverSchemaForApiModel } from '../services/schema-discovery/index.js';
import {
  extractMongooseModelMetadata,
  extractApiModelMetadata
} from '../mcp/utils/schema-metadata.js';

const debugLog = debug('<%= object %>sController');
const service = '<%= service %>s';

async function getModels(): Promise<{ Model: any; Trash: any }> {
  const m = await modelsPromise;
  return { Model: m.<%= service %>s, Trash: m.Trash };
}

type <%= service %>sRouteHandler = (req: ExpressRequest, res: ExpressResponse, next: ExpressNext) => Promise<void>;

export interface <%= service %>sControllerType {
  buildProjection(projections: string): Record<string, number>;
  find: <%= service %>sRouteHandler;
  getSchema: <%= service %>sRouteHandler;
  findOne: <%= service %>sRouteHandler;
  create: <%= service %>sRouteHandler;
  update: <%= service %>sRouteHandler;
  updateOne: <%= service %>sRouteHandler;
  delete: <%= service %>sRouteHandler;
  deleteOne: <%= service %>sRouteHandler;
  restore: <%= service %>sRouteHandler;
}

const <%= service %>sController: <%= service %>sControllerType = {
  buildProjection(projections: string): Record<string, number> {
    debugLog('starting build...');
    const projection = projections.split(','); // Projection should be comma separated. eg. name,location
    const select: Record<string, number> = {};
    
    projection.forEach((field) => {
      if (typeof field === 'string' && field.trim()) {
        debugLog('Processing...', field.trim());
        select[field.trim()] = 1;
      }
    });
    
    debugLog('Coming out of the loop...', select);
    return select;
  },

  /**
   * Find multiple <%= service %> records with filtering, pagination, and search
   * @mcp.expose true
   * @mcp.toolName find<%= service %>s
   * @mcp.description Find and list <%= service %> records with optional filtering, pagination, sorting, and full-text search
   */
  find: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      let query: any = {};
      
      if (req.query.search) {
        const raw = req.query.search;
        let parsed: any;
        try {
          parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;
        } catch {
          parsed = raw;
        }
        if (typeof parsed === 'string') {
          const resp = await (Model as any).search(parsed);
          res.ok?.(resp);
          return;
        }
        query = parsed;
        // Clean appId and userId
        if (query && query.appId) {
          delete query.appId;
        }
        if (query && query.accountId) {
          delete query.accountId;
        }
      } else {
        query = { ...req.query };
        // Clean appId and userId
        if (query && query.appId) {
          delete query.appId;
        }
        if (query && query.accountId) {
          delete query.accountId;
        }
      }

      const projection = query.select; // Projection should be comma separated. eg. name,location
        let ourProjection: Record<string, number> | undefined;
        
        if (projection) {
          ourProjection = <%= service %>sController.buildProjection(projection);
          delete query.select;
        }
        
        let limit = query.limit ? parseInt(query.limit as string, 10) : undefined;
        if (limit) {
          delete query.limit;
        }
        
        const from = query.from;
        const to = query.to;
        if (from) {
          query.createdAt = {};
          query.createdAt.$gt = from;
          delete query.from;
          if (to) {
            delete query.to;
          } else {
            query.createdAt.$lt = new Date().toISOString();
          }
          query.createdAt.$lt = to || new Date().toISOString();
        } else {
          query.createdAt = {};
          query.createdAt.$gt = new Date('1989-03-15T00:00:00').toISOString();
          if (to) {
            delete query.to;
          }
          query.createdAt.$lt = to || new Date().toISOString();
        }
        
        const lastId = query.lastId;
        if (lastId) {
          if (query.desc) {
            query._id = {};
            query._id.$lt = lastId;
            delete query.desc;
          } else {
            query._id = {};
            query._id.$gt = lastId;
          }
          delete query.lastId;
        }
        if (query.desc) {
          delete query.desc;
        }
        
        const sort = query.sort; // -fieldName: means descending while fieldName without the minus mean ascending both by fieldName. eg, '-fieldName1 fieldName2'
        if (sort) {
          delete query.sort;
        }
        
        const populate = query.populate; // Samples: 'name location' will populate name and location references. only supports this for now | 'name', 'firstname' will populate name reference and only pick the firstname attribute
        if (populate) {
          delete query.populate;
        }
        
        const totalResult = (Model as any).estimatedDocumentCount(query);
        const total = (Model as any).estimatedDocumentCount({});
        let question = (Model as any).find(query);

        if (limit) {
          question = question.limit(limit);
        } else {
          limit = 50;
          question = question.limit(limit);
        }
        
        if (sort) {
          question = question.sort(sort);
        }
        
        if (populate) {
          question = question.populate(populate);
        }

        if (projection && ourProjection) {
          const [resp, totalCount, totalResultCount] = await Promise.all([
            question.select(ourProjection).lean(),
            total,
            totalResult
          ]);
          
          const ourLastId = resp.length === 0 ? null : resp[resp.length - 1]._id;
          const extraData = {
            limit: limit * 1,
            total: totalCount,
            totalResult: totalResultCount,
            lastId: ourLastId,
            isLastPage: (totalResultCount < limit)
          };
          res.ok?.(resp, false, extraData);
        } else {
          const [resp, totalCount, totalResultCount] = await Promise.all([
            question.lean(),
            total,
            totalResult
          ]);
          
          const ourLastId = resp.length === 0 ? null : resp[resp.length - 1]._id;
          const extraData = {
            limit: limit * 1,
            total: totalCount,
            lastId: ourLastId,
            totalResult: totalResultCount,
            isLastPage: (totalResultCount < limit)
          };
          res.ok?.(resp, false, extraData);
        }
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Find a single <%= service %> record by ID
   * @mcp.expose true
   * @mcp.toolName get<%= service %>ById
   * @mcp.description Retrieve a single <%= service %> record by its unique identifier
   */
  findOne: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      const id = req.params.id;
      const query: any = req.query || {};
      const populate = query.populate; // Samples: 'name location' will populate name and location references. only supports this for now | 'name', 'firstname' will populate name reference and only pick the firstname attribute
      
      let question = (Model as any).findById(id);
      if (populate) {
        delete query.populate;
        question = question.populate(populate);
      }

      const resp = await question.lean();
      if (!resp) {
        res.notFound?.();
      } else {
        res.ok?.(resp);
      }
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Create a new <%= service %> record
   * @mcp.expose true
   * @mcp.toolName create<%= service %>
   * @mcp.description Create a new <%= service %> record with the provided data
   */
  create: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      const data: any = Array.isArray(req.body) ? req.body : { ...req.body };
      if (data && !Array.isArray(data) && data.secure) {
        delete data.secure;
      }
      if (Array.isArray(data)) {
        data.forEach((item: any) => item && item.secure && delete item.secure);
      }
      const resp = await (Model as any).create(data);
      res.ok?.(resp);
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Update multiple <%= service %> records matching the query
   * @mcp.expose true
   * @mcp.toolName update<%= service %>s
   * @mcp.description Update multiple <%= service %> records that match the specified query criteria
   */
  update: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      const query: any = { ...req.query };
      // Clean appId and userId
      if (query && query.appId) {
        delete query.appId;
      }
      if (query && query.accountId) {
        delete query.accountId;
      }
      
      const data: any = { ...req.body };
      if (data && data.secure) {
        delete data.secure;
      }
      
      const resp = await (Model as any).updateMany(query, data);
      res.ok?.(resp);
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Update a single <%= service %> record by ID
   * @mcp.expose true
   * @mcp.toolName update<%= service %>ById
   * @mcp.description Update a single <%= service %> record by its unique identifier
   */
  updateOne: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      const id = req.params.id;
      const data: any = { ...req.body };
      if (data && data.secure) {
        delete data.secure;
      }
      
      const resp = await (Model as any).findByIdAndUpdate(id, data, { new: true });
      if (!resp) {
        res.notFound?.();
      } else {
        res.ok?.(resp);
      }
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Delete multiple <%= service %> records matching the query
   * @mcp.expose true
   * @mcp.toolName delete<%= service %>s
   * @mcp.description Delete multiple <%= service %> records that match the specified query criteria. Deleted records are moved to trash for potential restoration.
   */
  delete: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      const query: any = { ...req.query };
      // Clean appId and userId
      if (query && query.appId) {
        delete query.appId;
      }
      if (query && query.accountId) {
        delete query.accountId;
      }
      
      // Find matches
      const resp = await (Model as any).find(query).lean();
      
      // Backup data in Trash
      for (const item of resp) {
        const backupData = {
          service: service,
          data: item,
          owner: req.accountId,
          deletedBy: req.accountId,
          client: req.appId,
          developer: req.developer
        };
        
        queue.create('saveToTrash', backupData).save();
      }
      
      // Delete matches
      await (Model as any).deleteMany(query);
      res.ok?.(resp);
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Delete a single <%= service %> record by ID
   * @mcp.expose true
   * @mcp.toolName delete<%= service %>ById
   * @mcp.description Delete a single <%= service %> record by its unique identifier. The deleted record is moved to trash for potential restoration.
   */
  deleteOne: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      const id = req.params.id;
      
      // Find match
      const resp = await (Model as any).findById(id).lean();
      if (!resp) {
        res.notFound?.();
        return;
      }
      
      // Backup data in Trash
      const backupData = {
        service: service,
        data: resp,
        owner: req.accountId,
        deletedBy: req.accountId,
        client: req.appId,
        developer: req.developer
      };
      
      queue.create('saveToTrash', backupData).save();
      
      // Delete match
      await (Model as any).findByIdAndDelete(id);
      res.ok?.(resp);
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Restore a deleted <%= service %> record from trash
   * @mcp.expose true
   * @mcp.toolName restore<%= service %>
   * @mcp.description Restore a previously deleted <%= service %> record from the trash back to the main collection
   */
  restore: async function (req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      const id = req.params.id;
      
      // Find data by ID from trash
      const trashItem = await (Trash as any).findById(id).lean();
      if (!trashItem) {
        res.notFound?.();
        return;
      }
      
      // Restore to DB
      const resp = await (Model as any).create(trashItem.data);
      
      // Delete from trash
      await (Trash as any).findByIdAndDelete(id);
      res.ok?.(resp);
    } catch (err: any) {
      next(err);
    }
  },

  /**
   * Get schema metadata for this model (MongoDB, or API with optional discovery + fallback)
   * @mcp.expose true
   * @mcp.toolName get<%= service %>Schema
   * @mcp.description Get the schema definition for <%= service %> records (fields, types, descriptions) for use by MCP and API consumers
   */
  getSchema: async function (_req: ExpressRequest, res: ExpressResponse, next: ExpressNext): Promise<void> {
    try {
      const { Model, Trash } = await getModels();
      const modelName = service;
      let metadata: { name: string; fields: any[]; description?: string; mcpDescription?: string; collection?: string; table?: string } | null = null;

      if (typeof (Model as any)._baseurl === 'string' && typeof (Model as any)._endpoint === 'string') {
        metadata = await discoverSchemaForApiModel(Model, modelName);
        if (!metadata && (Model as any)._schema) {
          metadata = extractApiModelMetadata(modelName, Model);
        }
        if (!metadata) {
          metadata = { name: modelName, fields: [] };
        }
      } else if ((Model as any)._schema) {
        metadata = extractApiModelMetadata(modelName, Model);
      } else if ((Model as any).schema) {
        metadata = extractMongooseModelMetadata(modelName, Model as import('../types/models.js').MongooseModelType);
      }

      if (!metadata) {
        res.notFound?.();
        return;
      }
      res.ok?.(metadata);
    } catch (err: any) {
      next(err);
    }
  }
};

export default <%= service %>sController;
